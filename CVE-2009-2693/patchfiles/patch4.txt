--- tomcat/tc6.0.x/trunk/java/org/apache/catalina/startup/HostConfig.java	2009/12/21 13:26:52	892814
+++ tomcat/tc6.0.x/trunk/java/org/apache/catalina/startup/HostConfig.java	2009/12/21 13:27:57	892815
@@ -28,7 +28,9 @@
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.LinkedHashMap;
+import java.util.Set;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 
@@ -152,6 +154,11 @@
      */
     protected static Digester digester = createDigester();
 
+    /**
+     * The list of Wars in the appBase to be ignored because they are invalid
+     * (e.g. contain /../ sequences).
+     */
+    protected Set<String> invalidWars = new HashSet<String>();
 
     // ------------------------------------------------------------- Properties
 
@@ -706,13 +713,22 @@
             if (files[i].equalsIgnoreCase("WEB-INF"))
                 continue;
             File dir = new File(appBase, files[i]);
-            if (files[i].toLowerCase().endsWith(".war") && dir.isFile()) {
+            if (files[i].toLowerCase().endsWith(".war") && dir.isFile()
+                    && !invalidWars.contains(files[i]) ) {
                 
                 // Calculate the context path and make sure it is unique
                 String contextPath = "/" + files[i].replace('#','/');
                 int period = contextPath.lastIndexOf(".");
-                if (period >= 0)
-                    contextPath = contextPath.substring(0, period);
+                contextPath = contextPath.substring(0, period);
+                
+                // Check for WARs with /../ /./ or similar sequences in the name
+                if (!validateContextPath(appBase, contextPath)) {
+                    log.error(sm.getString(
+                            "hostConfig.illegalWarName", files[i]));
+                    invalidWars.add(files[i]);
+                    continue;
+                }
+
                 if (contextPath.equals("/ROOT"))
                     contextPath = "";
                 
@@ -730,6 +746,42 @@
     }
 
 
+    private boolean validateContextPath(File appBase, String contextPath) {
+        // More complicated than the ideal as the canonical path may or may
+        // not end with File.separator for a directory
+        
+        StringBuilder docBase;
+        String canonicalDocBase = null;
+        
+        try {
+            String canonicalAppBase = appBase.getCanonicalPath();
+            docBase = new StringBuilder(canonicalAppBase);
+            if (canonicalAppBase.endsWith(File.separator)) {
+                docBase.append(contextPath.substring(1).replace(
+                        '/', File.separatorChar));
+            } else {
+                docBase.append(contextPath.replace('/', File.separatorChar));
+            }
+            // At this point docBase should be canonical but will not end
+            // with File.separator
+            
+            canonicalDocBase =
+                (new File(docBase.toString())).getCanonicalPath();
+    
+            // If the canonicalDocBase ends with File.separator, add one to
+            // docBase before they are compared
+            if (canonicalDocBase.endsWith(File.separator)) {
+                docBase.append(File.separator);
+            }
+        } catch (IOException ioe) {
+            return false;
+        }
+        
+        // Compare the two. If they are not the same, the contextPath must
+        // have /../ like sequences in it 
+        return canonicalDocBase.equals(docBase.toString());
+    }
+
     /**
      * @param contextPath
      * @param war
